package alekseytyan.codewars;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * If you finish this kata, you can try Insane Coloured Triangles by Bubbler,
 * which is a much harder version of this one.
 *
 * A coloured triangle is created from a row of colours, each of which is red, green or blue.
 * Successive rows, each containing one fewer colour than the last, are generated by considering
 * the two touching colours in the previous row. If these colours are identical,
 * the same colour is used in the new row. If they are different, the missing
 * colour is used in the new row. This is continued until the final row,
 * with only a single colour, is generated.
 *
 * The different possibilities are:
 *
 * Colour here:        G G        B G        R G        B R
 * Becomes colour:      G          R          B          G
 * With a bigger example:
 *
 * R R G B R G B B
 *  R B R G B R B
 *   G G B R G G
 *    G R G B G
 *     B B R R
 *      B G R
 *       R B
 *        G
 * You will be given the first row of the triangle as a string and its your job to return
 * the final colour which would appear in the bottom row as a string. In the case of the example
 * above, you would the given RRGBRGBB you should return G.
 *
 * The input string will only contain the uppercase letters R, G, B and there will be
 * at least one letter so you do not have to test for invalid input.
 * If you are only given one colour as the input, return that colour.
 */
public class ColouredTriangles {

    public static Set<Character> set = new HashSet<>(Arrays.asList('R','G','B'));

    // My solution
    public static char triangle(final String row) {

        StringBuilder mRow = new StringBuilder(row);
        StringBuilder curRow = new StringBuilder();

        while (mRow.length() > 1) {
            for (int i = 0; i < mRow.length() - 1; i++) {
                if(mRow.charAt(i) == mRow.charAt(i+1)) {
                    curRow.append(mRow.charAt(i));
                } else {
                    Set<Character> curSet = new HashSet<>(set);
                    curSet.remove(mRow.charAt(i));
                    curSet.remove(mRow.charAt(i+1));
                    curRow.append(curSet.toArray()[0]);
                }
            }
            mRow.delete(0, mRow.length());
            mRow.append(curRow);
            curRow.delete(0, curRow.length());
        }
        return mRow.charAt(0);
    }

    // Most ratted approach
    static char trianglePro(final String row) {

        if (row.length() == 1) return row.charAt(0);

        StringBuilder nextRow = new StringBuilder();
        for (int i = 0; i < row.length() - 1; i++) {
            char c1 = row.charAt(i), c2 = row.charAt(i + 1);
            switch (c1) {
                case 'R': nextRow.append(c2 == 'R' ? 'R' : c2 == 'G' ? 'B' : 'G'); break;
                case 'G': nextRow.append(c2 == 'R' ? 'B' : c2 == 'G' ? 'G' : 'R'); break;
                case 'B': nextRow.append(c2 == 'R' ? 'G' : c2 == 'G' ? 'R' : 'B'); break;
            }
        }

        return trianglePro(nextRow.toString()); // recurse
    }
}